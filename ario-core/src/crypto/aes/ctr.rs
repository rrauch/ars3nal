use crate::buffer::BufError;
use crate::confidential::RevealExt;
use crate::crypto::aes::{Aes, AesCipher, AesKey, Block, BlockFragment, Cipher, Nonce, Op};
use crate::crypto::encryption;
use crate::crypto::encryption::hazmat::SeekableDecryptor;
use crate::crypto::encryption::{Decryptor, Encryptor, Scheme};
use aes::cipher::consts::U12;
use aes::cipher::{BlockSizeUser, InOutBuf, KeyInit, StreamCipherCore, StreamCipherSeekCore};
use bytes::{Buf, BufMut};
use crypto_common::Generate;
use ctr::cipher::InnerIvInit;
use hybrid_array::ArraySize;
use maybe_owned::MaybeOwned;
use std::marker::PhantomData;
use thiserror::Error;

pub(super) struct AesCtrCore<
    const BIT: usize,
    F,
    NonceSize,
    const P_MAX: u64,
    const C_MAX: u64,
    const CTR_OFFSET: u64 = 0,
> where
    NonceSize: ArraySize,
    Aes<BIT>: AesCipher,
    F: Flavour<BIT>,
{
    ctr: CoreCtr<BIT, F>,
    pos: u64,
    _marker: PhantomData<NonceSize>,
}

#[derive(Error, Debug)]
pub enum Error {
    #[error(transparent)]
    BufError(#[from] BufError),
    #[error("ciphertext exceeds maximum allowed length")]
    CiphertextTooLong,
    #[error("plaintext exceeds maximum allowed length")]
    PlaintextTooLong,
    #[error("invalid seek position: '{0}' - must be aligned with block size")]
    InvalidSeekPosition(u64),
    #[error("decryption error")]
    DecryptionError,
    #[error("mode error: {0}")]
    Other(String),
}

impl From<Error> for encryption::Error {
    fn from(value: Error) -> Self {
        encryption::Error::Other(value.to_string())
    }
}

pub trait Flavour<const BIT: usize>:
    ctr::CtrFlavor<<<Aes<BIT> as AesCipher>::Cipher as BlockSizeUser>::BlockSize>
where
    Aes<BIT>: AesCipher,
{
}

impl<
    const BIT: usize,
    F: ctr::CtrFlavor<<<Aes<BIT> as AesCipher>::Cipher as BlockSizeUser>::BlockSize>,
> Flavour<BIT> for F
where
    Aes<BIT>: AesCipher,
{
}

pub type CoreCtr<const BIT: usize, F: Flavour<BIT>>
where
    Aes<BIT>: AesCipher,
= ctr::CtrCore<<Aes<BIT> as AesCipher>::Cipher, F>;

impl<const BIT: usize, F, NonceSize, const P_MAX: u64, const C_MAX: u64, const CTR_OFFSET: u64>
    AesCtrCore<BIT, F, NonceSize, P_MAX, C_MAX, CTR_OFFSET>
where
    NonceSize: ArraySize,
    Aes<BIT>: AesCipher,
    F: Flavour<BIT>,
{
    pub fn new(ctr: CoreCtr<BIT, F>, pos: u64) -> Self {
        Self {
            ctr,
            pos,
            _marker: PhantomData,
        }
    }

    #[inline]
    pub fn position(&self) -> u64 {
        self.pos
    }

    #[inline]
    pub fn seek(&mut self, pos: u64) -> Result<(), Error> {
        let block_size = Cipher::block_size() as u64;

        if pos % block_size != 0 {
            return Err(Error::InvalidSeekPosition(pos));
        }

        self.ctr.set_block_pos(
            <CoreCtr<BIT, F> as StreamCipherSeekCore>::Counter::try_from(
                (pos / block_size) + CTR_OFFSET,
            ) // payload starts at CTR_OFFSET
            .map_err(|_| Error::InvalidSeekPosition(pos))?,
        );

        self.pos = pos;

        Ok(())
    }

    #[inline]
    pub fn update(
        &mut self,
        input: &[u8],
        output: &mut [u8],
        mut handler: impl FnMut(&[Block<BIT>]) -> (),
        op: Op,
    ) -> Result<u64, Error> {
        assert_eq!(input.len(), output.len());

        let len = input.len() as u64;
        assert!(len > 0);

        if self.pos + len > C_MAX {
            return Err(Error::CiphertextTooLong);
        }

        if self.pos + len > P_MAX {
            return Err(Error::PlaintextTooLong);
        }

        let (mut blocks, tail) = InOutBuf::new(input, output).unwrap().into_chunks();

        if !tail.is_empty() {
            panic!("input must be multiple of block size");
        }

        self.ctr.apply_keystream_blocks_inout(blocks.reborrow());
        let buf = match op {
            Op::Enc => blocks.get_out(),
            Op::Dec => blocks.get_in(),
        };

        handler(buf);

        self.pos += len;

        Ok(len)
    }

    #[inline]
    pub fn finalize(
        mut self,
        input: &[u8],
        output: &mut [u8],
        mut handler: impl FnMut(&[u8]) -> (),
        op: Op,
    ) -> Result<u64, Error> {
        assert_eq!(input.len(), output.len());

        if !input.is_empty() {
            let len = input.len();
            if self.pos + len as u64 > C_MAX {
                return Err(Error::CiphertextTooLong);
            }

            if self.pos + len as u64 > P_MAX {
                return Err(Error::PlaintextTooLong);
            }

            let len = input.len();
            let mut buf = InOutBuf::new(input, output).unwrap();
            self.ctr.apply_keystream_partial(buf.reborrow());
            let buf = match op {
                Op::Enc => buf.get_out(),
                Op::Dec => buf.get_in(),
            };
            handler(&buf[..len]);

            self.pos += len as u64;
        }

        Ok(self.pos)
    }
}

pub trait SupportedAesCiphers<const BIT: usize> {}
impl SupportedAesCiphers<256> for aes::Aes256 {}

/// Maximum length of plaintext.
const P_MAX: u64 = 1 << 36;

/// Maximum length of ciphertext.
const C_MAX: u64 = 1 << 36;

type CtrFlavour = ctr::flavors::Ctr32BE;
type Ctr<const BIT: usize> = CoreCtr<BIT, CtrFlavour>;

pub struct AesCtr<const BIT: usize>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    core: AesCtrCore<BIT, CtrFlavour, U12, P_MAX, C_MAX, 0>,
}

impl<const BIT: usize> AesCtr<BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    fn new(key: &AesKey<BIT>, nonce: &Nonce<U12>) -> Self {
        let cipher = <Aes<BIT> as AesCipher>::Cipher::new(key.0.reveal());

        let mut block = Block::default();
        block[..12].copy_from_slice(nonce);
        //block[15] = 1; //

        let ctr = Ctr::inner_iv_init(cipher, &block);
        let core = AesCtrCore::new(ctr, 0);

        Self { core }
    }

    #[inline]
    fn position(&self) -> u64 {
        self.core.position()
    }

    #[inline]
    fn seek(&mut self, pos: u64) -> Result<(), crate::crypto::aes::gcm::Error> {
        Ok(self.core.seek(pos)?)
    }

    #[inline]
    fn update(&mut self, input: &[u8], output: &mut [u8], op: Op) -> Result<u64, Error> {
        Ok(self.core.update(input, output, |_| (), op)?)
    }

    #[inline]
    fn finalize(self, input: &[u8], output: &mut [u8], op: Op) -> Result<(), Error> {
        self.core.finalize(input, output, |_| (), op)?;
        Ok(())
    }

    pub fn generate_nonce() -> Nonce<U12> {
        Nonce::<U12>::generate()
    }
}

#[derive(Clone)]
pub struct AesCtrParams<'a, const BIT: usize>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    key: MaybeOwned<'a, AesKey<BIT>>,
    nonce: MaybeOwned<'a, Nonce<U12>>,
}

impl<'a, const BIT: usize> AesCtrParams<'a, BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    pub fn new(
        key: impl Into<MaybeOwned<'a, AesKey<BIT>>>,
        nonce: impl Into<MaybeOwned<'a, Nonce<U12>>>,
    ) -> Self {
        Self {
            key: key.into(),
            nonce: nonce.into(),
        }
    }
}

impl<const BIT: usize> Scheme for AesCtr<BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    type Encryptor<'a> = AesCtrEncryptor<'a, BIT>;
    type EncryptionParams<'a> = AesCtrParams<'a, BIT>;
    type Decryptor<'a> = AesCtrDecryptor<'a, BIT>;
    type DecryptionParams<'a> = AesCtrParams<'a, BIT>;
    type Error = Error;

    fn new_encryptor<'a>(
        params: Self::EncryptionParams<'a>,
    ) -> Result<Self::Encryptor<'a>, Self::Error> {
        let aes_ctr = AesCtr::new(params.key.as_ref(), params.nonce.as_ref());
        Ok(AesCtrEncryptor {
            aes_ctr,
            params,
            block_fragment: BlockFragment::new(),
        })
    }

    fn new_decryptor<'a>(
        params: Self::DecryptionParams<'a>,
    ) -> Result<Self::Decryptor<'a>, Self::Error> {
        let aes_ctr = AesCtr::new(params.key.as_ref(), params.nonce.as_ref());
        Ok(AesCtrDecryptor {
            aes_ctr,
            params,
            block_fragment: BlockFragment::new(),
        })
    }
}

pub struct AesCtrEncryptor<'a, const BIT: usize>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    aes_ctr: AesCtr<BIT>,
    params: AesCtrParams<'a, BIT>,
    block_fragment: BlockFragment<BIT>,
}

impl<'a, const BIT: usize> Encryptor<'a> for AesCtrEncryptor<'a, BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    type Error = Error;
    type AuthenticationTag = ();
    type Alignment = <<Aes<BIT> as AesCipher>::Cipher as BlockSizeUser>::BlockSize;

    fn position(&self) -> u64 {
        self.aes_ctr.position()
    }

    fn update<I: Buf, O: BufMut>(
        &mut self,
        plaintext: &mut I,
        ciphertext: &mut O,
    ) -> Result<(), Self::Error> {
        process(
            plaintext,
            ciphertext,
            &mut self.block_fragment,
            &mut self.aes_ctr,
            Op::Enc,
        )?;
        Ok(())
    }

    fn finalize(self) -> Result<(Self::AuthenticationTag, Option<Vec<u8>>), Self::Error> {
        let (auth_res, residual) =
            process_finalize(self.block_fragment, |plaintext, ciphertext| {
                self.aes_ctr.finalize(plaintext, ciphertext, Op::Enc)?;
                Ok(())
            });
        auth_res?;
        Ok(((), residual))
    }
}

pub struct AesCtrDecryptor<'a, const BIT: usize>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    aes_ctr: AesCtr<BIT>,
    params: AesCtrParams<'a, BIT>,
    block_fragment: BlockFragment<BIT>,
}

impl<'a, const BIT: usize> Decryptor<'a> for AesCtrDecryptor<'a, BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    type Error = Error;
    type AuthenticationTag = ();
    type Alignment = <<Aes<BIT> as AesCipher>::Cipher as BlockSizeUser>::BlockSize;

    fn position(&self) -> u64 {
        self.aes_ctr.position()
    }

    fn update<I: Buf, O: BufMut>(
        &mut self,
        ciphertext: &mut I,
        plaintext: &mut O,
    ) -> Result<(), Self::Error> {
        process(
            ciphertext,
            plaintext,
            &mut self.block_fragment,
            &mut self.aes_ctr,
            Op::Dec,
        )?;
        Ok(())
    }

    fn finalize(self, _: &Self::AuthenticationTag) -> (Result<(), Self::Error>, Option<Vec<u8>>) {
        process_finalize(self.block_fragment, |ciphertext, plaintext| {
            self.aes_ctr.finalize(ciphertext, plaintext, Op::Dec)?;
            Ok(())
        })
    }
}

impl<'a, const BIT: usize> SeekableDecryptor<'a> for AesCtrDecryptor<'a, BIT>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    fn seek(&mut self, position: u64) -> Result<(), Self::Error> {
        let current_pos = self.aes_ctr.position();
        if position == current_pos {
            return Ok(());
        }

        self.aes_ctr.seek(position)?;
        self.block_fragment.clear();
        Ok(())
    }
}

fn process<I: Buf, O: BufMut, const BIT: usize>(
    input: &mut I,
    output: &mut O,
    block_fragment: &mut BlockFragment<BIT>,
    aes_ctr: &mut AesCtr<BIT>,
    op: Op,
) -> Result<(), Error>
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    Ok(super::process(
        input,
        output,
        block_fragment,
        |input, output| aes_ctr.update(input, output, op).map(|n| n as usize),
    )?)
}

fn process_finalize<const BIT: usize>(
    block_fragment: BlockFragment<BIT>,
    handler: impl FnOnce(&[u8], &mut [u8]) -> Result<(), Error>,
) -> (Result<(), Error>, Option<Vec<u8>>)
where
    Aes<BIT>: AesCipher,
    <Aes<BIT> as AesCipher>::Cipher: SupportedAesCiphers<BIT>,
{
    super::process_finalize(block_fragment, handler)
}

#[cfg(test)]
mod tests {
    use crate::crypto::aes::ctr::{AesCtr, AesCtrParams};
    use crate::crypto::aes::{AesKey, Nonce};
    use crate::crypto::encryption::{DecryptionExt, EncryptionExt};
    use aes::cipher::consts::U12;
    use bytes::BytesMut;
    use futures_lite::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt};
    use hex_literal::hex;
    use std::io::{Cursor, Read, Seek, SeekFrom};

    static ONE_MB: &'static [u8] = include_bytes!("../../../testdata/1mb.bin");

    #[derive(Debug)]
    pub struct TestVector<K: 'static, N: 'static> {
        pub key: &'static K,
        pub nonce: &'static N,
        pub plaintext: &'static [u8],
        pub ciphertext: &'static [u8],
    }

    const TEST_VECTORS: &[TestVector<[u8; 32], [u8; 12]>] = &[
        TestVector {
            key: &[
                0x9e, 0x9f, 0x4b, 0x82, 0x5c, 0xbd, 0x9b, 0x59, 0xbb, 0x52, 0x6d, 0x2d, 0x0c, 0xcd,
                0xfd, 0xfc, 0xb3, 0xce, 0x9b, 0x9b, 0x4a, 0x4e, 0x9b, 0xaa, 0x6b, 0x43, 0x6f, 0x5d,
                0xf0, 0xe9, 0x05, 0x9c,
            ],
            nonce: &[
                0x54, 0xe0, 0x8c, 0x25, 0xa2, 0xcc, 0x1b, 0x6e, 0xf1, 0x44, 0x7d, 0x7d,
            ],
            plaintext: &[],
            ciphertext: &[],
        },
        TestVector {
            key: &[
                0x49, 0xdf, 0x99, 0x3e, 0xc6, 0xf0, 0x66, 0x5e, 0x3a, 0xdb, 0x27, 0x14, 0x20, 0xe8,
                0xb8, 0x5f, 0xf0, 0x5b, 0x3d, 0x90, 0xce, 0x0c, 0x79, 0xad, 0x0d, 0xd6, 0x87, 0x47,
                0xf8, 0xb2, 0x3a, 0xd9,
            ],
            nonce: &[
                0xd6, 0x8b, 0xcb, 0xf6, 0x5d, 0xb2, 0x2a, 0x2c, 0xd8, 0xc6, 0xea, 0xd9,
            ],
            plaintext: &[0x11],
            ciphertext: &[0xc9],
        },
        TestVector {
            key: &[
                0x07, 0x96, 0xda, 0xe4, 0xf4, 0x7d, 0x85, 0x0a, 0x25, 0x3b, 0x24, 0xda, 0x52, 0x7d,
                0x7a, 0xd8, 0x99, 0x1b, 0xd4, 0x34, 0xcb, 0x45, 0x9b, 0x5b, 0xa8, 0x80, 0x3e, 0xdb,
                0xfc, 0x10, 0x7a, 0x19,
            ],
            nonce: &[
                0xeb, 0x37, 0xe0, 0x79, 0x02, 0x19, 0xe5, 0x75, 0xe0, 0xef, 0xaa, 0xb4,
            ],
            plaintext: &[
                0xb7, 0x23, 0x30, 0xe7, 0xe8, 0x59, 0xe2, 0x0b, 0xb7, 0xb3, 0x2b, 0x71, 0x73, 0x62,
                0x9c,
            ],
            ciphertext: &[
                0x4d, 0x7e, 0x05, 0xf6, 0x4c, 0x6a, 0xd6, 0x20, 0xaf, 0xa6, 0xf1, 0x4d, 0x7c, 0x09,
                0xe8,
            ],
        },
        TestVector {
            key: &[
                0x67, 0x41, 0x46, 0x1b, 0x19, 0xcf, 0xf8, 0x46, 0x63, 0x7c, 0x22, 0xc7, 0x99, 0xb6,
                0x1c, 0x19, 0x92, 0x2e, 0xf7, 0xc8, 0x07, 0xb6, 0x7f, 0x55, 0x6f, 0x37, 0x01, 0xbf,
                0xeb, 0xf7, 0xa7, 0x39,
            ],
            nonce: &[
                0xec, 0xc2, 0x5d, 0x31, 0x09, 0xe6, 0x55, 0x65, 0x1c, 0xfa, 0x94, 0x2f,
            ],
            plaintext: &[
                0xbb, 0x91, 0xc5, 0x4d, 0x62, 0x8b, 0x3d, 0x24, 0x1b, 0x3e, 0x0c, 0x00, 0x41, 0xab,
                0xf1, 0xee,
            ],
            ciphertext: &[
                0xda, 0x70, 0x35, 0x49, 0x3f, 0x05, 0xf8, 0x07, 0x86, 0xe8, 0xf8, 0x4e, 0xc9, 0x35,
                0x3e, 0x62,
            ],
        },
        TestVector {
            key: &[
                0xaa, 0x68, 0x06, 0xb2, 0xd1, 0x9f, 0x3f, 0x99, 0xc8, 0xa1, 0x6c, 0xef, 0x14, 0x7e,
                0x92, 0xee, 0x69, 0x7c, 0x05, 0x58, 0x4a, 0x96, 0x9b, 0x9e, 0x85, 0x87, 0x4f, 0x6f,
                0x56, 0x92, 0x85, 0x4d,
            ],
            nonce: &[
                0x7a, 0x7a, 0x7c, 0x56, 0x12, 0xdd, 0xe7, 0x9c, 0x8a, 0xb9, 0x27, 0x46,
            ],
            plaintext: &[
                0xa2, 0x1f, 0x95, 0xff, 0x13, 0x34, 0xe8, 0xd0, 0x7a, 0xe3, 0x9b, 0x72, 0xb5, 0xe7,
                0x8a, 0x3d, 0x36,
            ],
            ciphertext: &[
                0x71, 0xda, 0xcf, 0x52, 0x0b, 0xf5, 0xb0, 0xb3, 0x20, 0x90, 0x88, 0x94, 0x51, 0x43,
                0x00, 0xd8, 0x20,
            ],
        },
        TestVector {
            key: &[
                0x2c, 0xd6, 0xfe, 0xbf, 0x14, 0x8e, 0x77, 0xb0, 0xe7, 0x0a, 0x9f, 0x96, 0xe0, 0x55,
                0x0b, 0x59, 0x79, 0x26, 0xdf, 0x0c, 0x84, 0xe6, 0x77, 0x32, 0x95, 0xdc, 0xf6, 0x89,
                0x0c, 0xc1, 0xac, 0x87,
            ],
            nonce: &[
                0x8b, 0xf2, 0xf5, 0x78, 0xf8, 0x9f, 0x85, 0x03, 0x60, 0x05, 0xb4, 0x05,
            ],
            plaintext: &[
                0x75, 0x91, 0xf7, 0x62, 0xef, 0x99, 0x77, 0xd0, 0x1c, 0xae, 0x99, 0xd3, 0xea, 0xfc,
                0x15, 0x5d, 0x7a, 0xe1, 0x56, 0x49, 0x39, 0x4b, 0x4d, 0x86, 0xc6, 0x88, 0xa9, 0xfc,
                0x7d, 0xaf, 0xcb,
            ],
            ciphertext: &[
                0x8d, 0x39, 0x3e, 0x0e, 0xed, 0x5a, 0xbc, 0x48, 0xf4, 0x68, 0x6a, 0xd6, 0x10, 0x55,
                0xda, 0x3e, 0x15, 0x8d, 0x9a, 0x5d, 0x07, 0x00, 0x1e, 0x2b, 0x85, 0xd6, 0x8a, 0x69,
                0x36, 0x86, 0x56,
            ],
        },
        TestVector {
            key: &[
                0x2f, 0xd7, 0xf7, 0x00, 0xe7, 0xda, 0x7d, 0x5c, 0xeb, 0x3a, 0x09, 0xb6, 0x51, 0x50,
                0x63, 0x1f, 0xdc, 0xfe, 0xbf, 0xbb, 0xc5, 0x66, 0x39, 0xe9, 0x15, 0xd3, 0x3b, 0xd9,
                0xfb, 0x70, 0x8b, 0x50,
            ],
            nonce: &[
                0xfd, 0x16, 0x9c, 0xe9, 0x87, 0x5f, 0x6f, 0x1a, 0x95, 0x1d, 0xa1, 0xb6,
            ],
            plaintext: &[
                0x19, 0x1c, 0x88, 0xd7, 0x54, 0x46, 0x4a, 0x3c, 0xad, 0x32, 0xa3, 0x30, 0x60, 0x05,
                0xe0, 0x42, 0x59, 0x9a, 0x64, 0x2f, 0x30, 0x00, 0xcc, 0x05, 0xc1, 0xf6, 0x22, 0xc3,
                0xe3, 0x19, 0x3a, 0xee,
            ],
            ciphertext: &[
                0x70, 0x2d, 0x74, 0xde, 0x75, 0x45, 0x01, 0x04, 0xa0, 0x1f, 0xba, 0x07, 0xdd, 0x94,
                0x2c, 0x82, 0xf8, 0x86, 0x6b, 0xc9, 0xc5, 0x27, 0x2f, 0x90, 0xd0, 0xbf, 0x56, 0xf6,
                0xc2, 0x11, 0x57, 0xd6,
            ],
        },
        TestVector {
            key: &[
                0xea, 0xa3, 0xc5, 0x29, 0x2b, 0xbc, 0xec, 0xdb, 0xab, 0xa6, 0xc2, 0x33, 0xd5, 0xf9,
                0xff, 0xa5, 0xd5, 0x4f, 0xa6, 0xd7, 0xf6, 0xa4, 0x4d, 0xff, 0xc4, 0xfe, 0x6b, 0x4e,
                0xb1, 0xa9, 0x5b, 0xf0,
            ],
            nonce: &[
                0x4f, 0x0f, 0xc5, 0x30, 0x15, 0xbf, 0x0f, 0xf4, 0x50, 0xcc, 0xe3, 0x5d,
            ],
            plaintext: &[
                0xa3, 0xb5, 0x76, 0xf4, 0x7e, 0xc5, 0x6c, 0xe2, 0xa8, 0xc4, 0xbd, 0x29, 0x5d, 0x31,
                0x05, 0xb0, 0x46, 0x03, 0x38, 0x81, 0xd4, 0xff, 0x42, 0x69, 0x98, 0x23, 0x32, 0x7d,
                0x00, 0x32, 0x37, 0x66, 0x29,
            ],
            ciphertext: &[
                0xc8, 0x34, 0xbf, 0x04, 0x8f, 0x2a, 0x31, 0x4e, 0x86, 0x5d, 0xb6, 0x47, 0xc2, 0xf7,
                0x14, 0xc6, 0xe8, 0x2e, 0x8f, 0xb2, 0x91, 0x4e, 0xea, 0xf8, 0x89, 0x9a, 0xee, 0x05,
                0x69, 0xf9, 0x12, 0x81, 0x68,
            ],
        },
        TestVector {
            key: &[
                0x0c, 0x11, 0xa1, 0xcb, 0xff, 0x76, 0x07, 0x75, 0xd7, 0xd6, 0x46, 0x3d, 0xf3, 0x67,
                0x8c, 0x48, 0x2a, 0xf7, 0xe3, 0x6e, 0xa1, 0x50, 0x09, 0xc9, 0x9d, 0x4a, 0x1d, 0xde,
                0xfe, 0x1f, 0x0a, 0x95,
            ],
            nonce: &[
                0x71, 0xb5, 0xc7, 0x22, 0x16, 0x8f, 0xd8, 0xea, 0x87, 0xe4, 0xc4, 0x2c,
            ],
            plaintext: &[
                0x3f, 0x75, 0x14, 0x36, 0xb1, 0x3a, 0x5c, 0xcf, 0xbc, 0x16, 0xbe, 0x30, 0x6b, 0x9a,
                0x53, 0xdc, 0x39, 0xf8, 0xf0, 0xf0, 0x13, 0x08, 0xcf, 0x2c, 0x98, 0x48, 0x61, 0x32,
                0x9f, 0xd5, 0x9f, 0xe2, 0x18, 0xd3, 0x8c, 0xee, 0xf2, 0x2d, 0x46, 0x42, 0x34, 0xa2,
                0x04, 0x4d, 0x48, 0xaf, 0x51, 0x25, 0x4c, 0xd0, 0x39, 0x22, 0xd6, 0xa9, 0xad, 0xd2,
                0x90, 0x7d, 0x13, 0xc3, 0xcc, 0x26, 0x89,
            ],
            ciphertext: &[
                0x3d, 0x4c, 0x44, 0x63, 0xa9, 0xfd, 0x1b, 0x7b, 0x2f, 0xf3, 0x56, 0x4a, 0xd7, 0x52,
                0x56, 0x0f, 0xb8, 0x30, 0xb1, 0xf2, 0x27, 0x8a, 0xc0, 0xa8, 0x5f, 0xf2, 0x9e, 0x33,
                0xbc, 0xe2, 0x5f, 0xe2, 0xd7, 0x79, 0x52, 0x82, 0x80, 0x08, 0xc0, 0xde, 0xa5, 0x19,
                0x1f, 0x5c, 0xac, 0x11, 0x50, 0xd8, 0x7c, 0x27, 0xc1, 0xb4, 0x20, 0x8e, 0xaf, 0x1c,
                0x0b, 0x2c, 0x21, 0x01, 0xb4, 0xc3, 0x96,
            ],
        },
        TestVector {
            key: &[
                0x40, 0xd3, 0xc6, 0xc5, 0x97, 0xfb, 0x9f, 0xda, 0x7d, 0x70, 0xb6, 0x9a, 0x95, 0x2e,
                0x61, 0x40, 0xc5, 0xb0, 0xc0, 0xcb, 0xed, 0x50, 0xdc, 0xff, 0xb5, 0xff, 0x6b, 0x6f,
                0xa4, 0xc3, 0x1d, 0xfb,
            ],
            nonce: &[
                0xa1, 0x5c, 0x0b, 0x6a, 0x4f, 0xa5, 0xdc, 0x7d, 0x27, 0x4c, 0x25, 0x16,
            ],
            plaintext: &[
                0xef, 0x92, 0x94, 0x01, 0x7a, 0xbe, 0x65, 0xb0, 0x95, 0x86, 0xab, 0x56, 0x50, 0xf8,
                0x6b, 0xa2, 0x78, 0xe8, 0x34, 0x84, 0x87, 0xa3, 0xb5, 0x24, 0xee, 0x19, 0x7b, 0x48,
                0xe9, 0x41, 0x8a, 0xeb, 0x8f, 0xee, 0xc2, 0x27, 0x3d, 0xc8, 0x78, 0x03, 0x7d, 0x84,
                0x65, 0x77, 0x64, 0xfe, 0xdd, 0xba, 0xfc, 0x48, 0xbb, 0xa4, 0x13, 0x1e, 0x12, 0x92,
                0x18, 0xc7, 0xd8, 0xa4, 0x10, 0xf8, 0x9e, 0x70,
            ],
            ciphertext: &[
                0xd3, 0x6c, 0x79, 0x6c, 0x46, 0x61, 0xc7, 0x76, 0x65, 0x16, 0x07, 0x69, 0xf0, 0xf1,
                0x32, 0x73, 0x60, 0xd2, 0xc0, 0x07, 0x25, 0x50, 0xc4, 0x00, 0x74, 0xff, 0xd3, 0x7f,
                0x1c, 0xfe, 0xb5, 0xcc, 0x2d, 0xf4, 0x38, 0x46, 0x5d, 0x4d, 0x62, 0x07, 0x81, 0xd7,
                0x9f, 0x9d, 0xd9, 0x7c, 0xf9, 0x82, 0x48, 0xfc, 0x1c, 0x45, 0x03, 0xee, 0x4d, 0x45,
                0x11, 0xb4, 0x51, 0xc4, 0x5c, 0x32, 0xf1, 0xb9,
            ],
        },
        TestVector {
            key: &[
                0xe0, 0xcf, 0x0e, 0xfc, 0x16, 0xa9, 0xad, 0x8b, 0xaf, 0xde, 0x24, 0x88, 0xce, 0x28,
                0x17, 0x9e, 0xd0, 0xb3, 0x0d, 0x1a, 0xc8, 0x34, 0x0e, 0xad, 0x6b, 0x75, 0x70, 0x7c,
                0x9c, 0x3f, 0xe9, 0x1c,
            ],
            nonce: &[
                0x5e, 0x6e, 0xaa, 0xc5, 0xd8, 0x05, 0xb5, 0xb5, 0xcd, 0x6c, 0x53, 0xc6,
            ],
            plaintext: &[
                0xcf, 0xdd, 0x42, 0x06, 0x2d, 0x31, 0xd8, 0x85, 0x3d, 0x7c, 0x88, 0xe5, 0xa6, 0xcd,
                0x63, 0xf3, 0x84, 0x50, 0xb4, 0x96, 0xa1, 0x74, 0xb9, 0xf4, 0xac, 0x4f, 0x44, 0x92,
                0x29, 0x55, 0x07, 0xe7, 0x6c, 0xc8, 0x0e, 0x34, 0x7a, 0xb0, 0x14, 0xbc, 0xa4, 0xb3,
                0x43, 0xb1, 0xcc, 0x9e, 0x0b, 0x71, 0x55, 0x9c, 0xb6, 0x00, 0xc2, 0x55, 0x63, 0xa2,
                0x01, 0x40, 0x8d, 0x08, 0xb6, 0x23, 0x5b, 0xe4, 0x3d,
            ],
            ciphertext: &[
                0x3f, 0xd7, 0x89, 0x9a, 0x51, 0xe0, 0xff, 0xde, 0xa9, 0x2c, 0x38, 0x17, 0xa9, 0x3f,
                0x90, 0x3a, 0x18, 0xf2, 0x40, 0xc2, 0x5d, 0xc8, 0x3d, 0xac, 0x29, 0x69, 0xbb, 0xea,
                0x41, 0xc9, 0x37, 0x09, 0xd7, 0x66, 0x16, 0x03, 0x5e, 0xa4, 0xf2, 0xe6, 0x33, 0x84,
                0x7e, 0x31, 0x10, 0x46, 0xee, 0x7e, 0xd2, 0x3d, 0x14, 0x55, 0x35, 0x7f, 0xcf, 0x62,
                0x36, 0xa0, 0x6a, 0xe1, 0x01, 0x83, 0x19, 0x0d, 0xbe,
            ],
        },
        TestVector {
            key: &[
                0x12, 0x3c, 0x16, 0x42, 0x0f, 0xba, 0x83, 0xca, 0x35, 0x23, 0xb0, 0x8b, 0x17, 0x74,
                0xd9, 0xe4, 0x4d, 0x21, 0xa0, 0x4b, 0xdc, 0x32, 0x01, 0xcc, 0x65, 0x48, 0xa7, 0xfc,
                0x79, 0x70, 0xb2, 0x9b,
            ],
            nonce: &[
                0x61, 0x5e, 0xde, 0xeb, 0x25, 0x55, 0x81, 0x53, 0xf8, 0x10, 0x02, 0x6f,
            ],
            plaintext: &[
                0xa2, 0x89, 0x62, 0xf6, 0xd2, 0xf7, 0x75, 0xaf, 0xed, 0x9f, 0xaa, 0x5d, 0x68, 0x28,
                0xd8, 0xbd, 0xf4, 0xe6, 0x41, 0xee, 0x83, 0x80, 0x0d, 0xb5, 0x26, 0x60, 0xf1, 0x59,
                0xfa, 0xbd, 0x3b, 0xca, 0x93, 0x96, 0x22, 0x73, 0x50, 0xe4, 0xb1, 0x45, 0xb5, 0x34,
                0xaf, 0x24, 0x74, 0xac, 0xeb, 0xfa, 0x95, 0x78, 0x5b, 0x15, 0x38, 0x70, 0x98, 0x0b,
                0x31, 0x33, 0x2c, 0xce, 0xa5, 0x15, 0x3e, 0x43, 0x68, 0x41, 0xf3, 0xc6, 0xe3, 0x27,
                0x84, 0x90, 0xce, 0x28, 0x89, 0xaa, 0x63, 0x1f, 0x38, 0x22, 0xc3, 0xbe, 0xba, 0xb0,
                0x55, 0x05, 0x7a, 0xb5, 0xbb, 0x5d, 0x7a, 0xbc, 0x9a, 0xcc, 0xce, 0xab, 0x83, 0xac,
                0x37, 0xa4,
            ],
            ciphertext: &[
                0x1c, 0xf7, 0x39, 0x15, 0x59, 0x0d, 0xa5, 0x78, 0xbc, 0xc8, 0x55, 0xa2, 0x0b, 0x91,
                0x0f, 0x9a, 0x54, 0xfa, 0xe9, 0xa9, 0xd0, 0xe9, 0x8c, 0xd9, 0x80, 0xca, 0x43, 0x21,
                0xd9, 0xb4, 0xb7, 0x12, 0x52, 0x42, 0x49, 0xbe, 0x45, 0xb7, 0xde, 0xde, 0xea, 0x71,
                0x85, 0xe1, 0x42, 0x26, 0x81, 0x9f, 0x59, 0x1b, 0x5b, 0x4e, 0x65, 0x26, 0x36, 0xf2,
                0x9e, 0xf1, 0xf3, 0x1a, 0x70, 0x2b, 0xb8, 0xac, 0xc4, 0x20, 0x04, 0x88, 0x22, 0xf2,
                0x02, 0xce, 0x38, 0xfd, 0x60, 0xac, 0x8e, 0x45, 0x17, 0x9c, 0x10, 0x2c, 0xe2, 0xbb,
                0x90, 0x5d, 0x53, 0x2a, 0xb9, 0x14, 0xd0, 0xba, 0xae, 0x26, 0xb1, 0x9c, 0x7e, 0x7b,
                0xa3, 0xc5,
            ],
        },
        TestVector {
            key: &[
                0x71, 0x5b, 0xc3, 0x92, 0x6c, 0xd6, 0xf8, 0xf8, 0x1b, 0x57, 0xe8, 0x91, 0x3d, 0x37,
                0xc8, 0x33, 0x75, 0x52, 0x89, 0xa1, 0x69, 0x25, 0xde, 0xb0, 0x8c, 0x14, 0x7b, 0x52,
                0xfa, 0x53, 0x77, 0x97,
            ],
            nonce: &[
                0x38, 0x53, 0xaf, 0xbe, 0xf2, 0xbb, 0x16, 0x4e, 0xed, 0xab, 0x11, 0x3d,
            ],
            plaintext: &[
                0xd9, 0xc4, 0x9a, 0xc3, 0x09, 0x7d, 0xaa, 0xb8, 0x68, 0x52, 0xdc, 0x28, 0x89, 0x80,
                0xbf, 0xc6, 0x61, 0xfa, 0xb1, 0x3a, 0x76, 0xf7, 0x93, 0x93, 0xd1, 0x2b, 0x47, 0xbf,
                0xe1, 0xd3, 0xf0, 0xe1, 0xb5, 0x49, 0xa5, 0x8d, 0xe0, 0xd1, 0x5f, 0xe1, 0xf7, 0x84,
                0x41, 0xca, 0x96, 0x74, 0xee, 0x73, 0x48, 0x9b, 0xf8, 0xb5, 0x1c, 0x8e, 0x3b, 0xad,
                0x43, 0x64, 0xfd, 0x11, 0xb7, 0x2e, 0xc3, 0x38, 0x68, 0x26, 0xd8, 0x17, 0xce, 0xa0,
                0xf4, 0x2c, 0x0e, 0xd6, 0x6a, 0x03, 0xcb, 0xe7, 0x25, 0x4d, 0xbf, 0x10, 0xab, 0x4f,
                0x1e, 0x55, 0x37, 0xa8, 0x71, 0xf5, 0x78, 0x3f, 0x10, 0xd1, 0xee, 0x89, 0x8c, 0x69,
                0x32, 0x4d, 0x24, 0x32, 0xfa, 0x31, 0xf9, 0xe8, 0xd3, 0xe3, 0x02, 0xd1, 0xbc, 0xaa,
                0xdf, 0xd3, 0xf2, 0x1e, 0xa0, 0x38, 0xea, 0xd4, 0x0f, 0x40, 0x66, 0xfb, 0xa5, 0xbd,
                0xb5, 0xfc, 0xe8, 0x48, 0x23, 0xba, 0xd5, 0xeb, 0x6b, 0x1a, 0x9a, 0x86, 0x6f, 0xbf,
                0x46, 0x10, 0x30, 0x22, 0x93, 0x6a, 0x8c, 0xde, 0x5b, 0x59, 0xf6, 0x1f, 0x2d, 0x1e,
                0x8d, 0xfa, 0x17, 0x82, 0xee, 0x70, 0x52, 0x2b, 0xba, 0x6d, 0x06, 0x5a, 0x02, 0x4c,
                0xf2, 0x1b, 0xfd, 0x09, 0xaf, 0x00, 0xcf, 0x95, 0x84, 0x14, 0x24, 0x18, 0x32, 0x43,
                0x35, 0x24, 0x35, 0x3b, 0x08, 0xf8, 0xdf, 0x9d, 0x65, 0x24, 0x81, 0x71, 0xca, 0x39,
                0x81, 0xd1, 0xb2, 0xb4, 0xbe, 0xdc, 0xb9, 0x9b, 0x11, 0x3e, 0x4a, 0x2c, 0xab, 0x9e,
                0x4e, 0x05, 0x97, 0x7c, 0xfd, 0x13, 0x77, 0x05, 0x9e, 0x14, 0xc7, 0x19, 0x5c, 0x79,
                0xf3, 0xef, 0xf6, 0xb6, 0xf8, 0xa1, 0x90, 0x6d, 0x94, 0x52, 0xd2, 0x69, 0xb6, 0xd6,
                0x33, 0xb5, 0x7a, 0x95, 0xab, 0xed, 0x0c, 0xd9, 0x56, 0x38, 0x07, 0x27, 0x26, 0x76,
                0xb5, 0x20, 0x27, 0x7e,
            ],
            ciphertext: &[
                0xf1, 0x1b, 0x2b, 0x9e, 0x76, 0x0c, 0x0a, 0xb5, 0x4e, 0x5f, 0x2e, 0x82, 0x8f, 0x66,
                0xa9, 0x35, 0xf4, 0x99, 0x06, 0x29, 0x3e, 0xb3, 0x8a, 0xff, 0x64, 0x83, 0x9b, 0xae,
                0x0c, 0xba, 0x1f, 0x1f, 0x55, 0xdf, 0xd4, 0x3b, 0x41, 0x81, 0x15, 0xf4, 0x2c, 0x10,
                0xa8, 0x99, 0xab, 0xfc, 0xa6, 0x0a, 0xfe, 0x1e, 0xca, 0xb9, 0xc3, 0x01, 0x87, 0x56,
                0xde, 0x7f, 0xdd, 0x76, 0x21, 0x83, 0x2f, 0xdf, 0x8d, 0xdb, 0x7d, 0x82, 0xb1, 0x55,
                0xfd, 0x21, 0x82, 0xb8, 0x1f, 0x49, 0x18, 0x21, 0x49, 0x84, 0xd2, 0xdd, 0x7a, 0x91,
                0xc3, 0xe6, 0x45, 0xd3, 0x7d, 0x7c, 0x20, 0x08, 0x52, 0xee, 0x0e, 0x76, 0x21, 0x7c,
                0x76, 0x70, 0x55, 0xf6, 0x52, 0x6b, 0x9c, 0x36, 0x1c, 0x27, 0x21, 0x69, 0x5b, 0x4e,
                0xdb, 0xa8, 0xda, 0x63, 0x6b, 0x4a, 0xc6, 0x54, 0xe1, 0x39, 0x43, 0x1b, 0xb8, 0x86,
                0x5f, 0xee, 0xf4, 0x3d, 0x91, 0x16, 0xff, 0x6c, 0x9f, 0x15, 0x8d, 0xd1, 0x78, 0xb0,
                0x1f, 0x10, 0xf5, 0xf2, 0x82, 0x4d, 0x4d, 0xac, 0x3d, 0x0e, 0xe2, 0xd1, 0xa6, 0xcb,
                0x0b, 0x55, 0x7a, 0xe5, 0x3d, 0xd1, 0xc2, 0xf1, 0xa0, 0x35, 0x73, 0x30, 0x51, 0x53,
                0xce, 0xf9, 0xd7, 0xd5, 0x82, 0x14, 0xa4, 0x4a, 0x1c, 0x6f, 0xfd, 0x0a, 0x3c, 0xbe,
                0x96, 0x35, 0x2c, 0x77, 0xf0, 0xba, 0xf9, 0xd7, 0x06, 0x87, 0x99, 0x30, 0x78, 0x89,
                0x2b, 0xff, 0xaf, 0x83, 0x60, 0xd7, 0xe8, 0x78, 0x08, 0x5f, 0x77, 0x88, 0xa1, 0xc6,
                0x54, 0x11, 0x84, 0xf8, 0xcf, 0xcd, 0x84, 0xbf, 0x86, 0xee, 0x0e, 0xa7, 0x3d, 0xab,
                0x1d, 0x12, 0x0b, 0x1d, 0x24, 0xe1, 0x95, 0x04, 0xf1, 0xc2, 0x28, 0x42, 0xe9, 0xb5,
                0xe2, 0x21, 0x73, 0xb3, 0x19, 0xe9, 0xe0, 0x46, 0x44, 0x45, 0x8e, 0x06, 0xae, 0x11,
                0xd2, 0xb1, 0x3f, 0xe9,
            ],
        },
    ];

    fn to_params(test: &TestVector<[u8; 32], [u8; 12]>) -> AesCtrParams<'_, 256> {
        let key = AesKey::try_from_bytes(test.key.as_slice()).unwrap();
        let nonce: Nonce<U12> = test.nonce.as_slice().try_into().unwrap();
        AesCtrParams::new(key, nonce)
    }

    #[test]
    fn simple_enc() -> anyhow::Result<()> {
        for test in TEST_VECTORS {
            let params = to_params(test);
            let mut plaintext = Cursor::new(test.plaintext);

            let mut output = BytesMut::with_capacity(test.ciphertext.len());
            let _ = AesCtr::encrypt(params, &mut plaintext, &mut output)?;
            let ciphertext = output.freeze();
            assert_eq!(ciphertext.to_vec().as_slice(), test.ciphertext);
            //println!("{}", hex::encode(test.key.as_slice()));
        }
        Ok(())
    }

    #[test]
    fn simple_dec() -> anyhow::Result<()> {
        for test in TEST_VECTORS {
            let params = to_params(test);
            let mut ciphertext = Cursor::new(test.ciphertext);

            let mut output = BytesMut::with_capacity(test.plaintext.len());
            AesCtr::decrypt(params, &mut ciphertext, &mut output, ())?;
            let plaintext = output.freeze();
            assert_eq!(plaintext.to_vec().as_slice(), test.plaintext);
        }
        Ok(())
    }

    #[test]
    fn readwrite_roundtrip() -> anyhow::Result<()> {
        let mut plaintext_reader = Cursor::new(ONE_MB);
        let mut ciphertext = Vec::with_capacity(ONE_MB.len());
        let key = AesKey::try_from_bytes(hex!(
            "1fded32d5999de4a76e0f8082108823aef60417e1896cf4218a2fa90f632ec8a"
        ))
        .unwrap();
        let nonce: Nonce<U12> = hex!("1f3afa4711e9474f32e70462").try_into()?;
        let params = AesCtrParams::new(key, nonce);
        let mut output = Cursor::new(&mut ciphertext);

        let _ = AesCtr::encrypt_readwrite(params.clone(), &mut plaintext_reader, &mut output)?;

        let mut ciphertext_reader = Cursor::new(ciphertext);

        let mut plaintext = Vec::with_capacity(ONE_MB.len());
        let mut output = Cursor::new(&mut plaintext);

        AesCtr::decrypt_readwrite(params, &mut ciphertext_reader, &mut output, ())?;

        assert_eq!(&plaintext, ONE_MB);

        Ok(())
    }

    #[tokio::test]
    async fn readwrite_async_roundtrip() -> anyhow::Result<()> {
        let mut plaintext_reader = futures_lite::io::Cursor::new(ONE_MB);
        let mut ciphertext = Vec::with_capacity(ONE_MB.len());
        let key = AesKey::try_from_bytes(hex!(
            "1fded32d5999de4a76e0f8082108823aef60417e1896cf4218a2fa90f632ec8a"
        ))
        .unwrap();
        let nonce: Nonce<U12> = hex!("1f3afa4711e9474f32e70462").try_into()?;
        let params = AesCtrParams::new(key, nonce);
        let mut output = futures_lite::io::Cursor::new(&mut ciphertext);

        let _ = AesCtr::encrypt_async_readwrite(params.clone(), &mut plaintext_reader, &mut output)
            .await?;

        let mut ciphertext_reader = futures_lite::io::Cursor::new(ciphertext);

        let mut plaintext = Vec::with_capacity(ONE_MB.len());
        let mut output = futures_lite::io::Cursor::new(&mut plaintext);

        AesCtr::decrypt_async_readwrite(params, &mut ciphertext_reader, &mut output, ()).await?;

        assert_eq!(&plaintext, ONE_MB);

        Ok(())
    }

    #[test]
    fn seek() -> anyhow::Result<()> {
        let mut plaintext_reader = Cursor::new(ONE_MB);
        let mut ciphertext = Vec::with_capacity(ONE_MB.len());
        let key = AesKey::try_from_bytes(hex!(
            "1fded32d5999de4a76e0f8082108823aef60417e1896cf4218a2fa90f632ec8a"
        ))
        .unwrap();
        let nonce: Nonce<U12> = hex!("1f3afa4711e9474f32e70462").try_into()?;
        let params = AesCtrParams::new(key, nonce);
        let mut output = Cursor::new(&mut ciphertext);

        let _ = AesCtr::encrypt_readwrite(params.clone(), &mut plaintext_reader, &mut output)?;

        let mut ciphertext_reader = Cursor::new(ciphertext);

        let mut decrypting_reader = AesCtr::decrypting_reader(params, &mut ciphertext_reader, ())?;

        fn seek_test<R: Read + Seek>(
            reader: &mut R,
            buffer: &mut [u8],
            pos: usize,
        ) -> anyhow::Result<()> {
            reader.seek(SeekFrom::Start(pos as u64))?;
            reader.read_exact(buffer)?;
            assert_eq!(buffer, &ONE_MB[pos..pos + buffer.len()]);
            Ok(())
        }

        let len = 4096;
        let mut buffer = vec![0u8; len];

        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 0)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 4096)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 25631)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 8192)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 55112)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 256256)?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 1000000)?;

        decrypting_reader.finalize()?;
        Ok(())
    }

    #[tokio::test]
    async fn seek_async() -> anyhow::Result<()> {
        let mut plaintext_reader = futures_lite::io::Cursor::new(ONE_MB);
        let mut ciphertext = Vec::with_capacity(ONE_MB.len());
        let key = AesKey::try_from_bytes(hex!(
            "1fded32d5999de4a76e0f8082108823aef60417e1896cf4218a2fa90f632ec8a"
        ))
        .unwrap();
        let nonce: Nonce<U12> = hex!("1f3afa4711e9474f32e70462").try_into()?;
        let params = AesCtrParams::new(key, nonce);
        let mut output = futures_lite::io::Cursor::new(&mut ciphertext);

        let _ = AesCtr::encrypt_async_readwrite(params.clone(), &mut plaintext_reader, &mut output)
            .await?;

        let mut ciphertext_reader = futures_lite::io::Cursor::new(ciphertext);

        let mut decrypting_reader =
            AesCtr::decrypting_async_reader(params, &mut ciphertext_reader, ())?;

        async fn seek_test<R: AsyncRead + AsyncSeek + Unpin>(
            reader: &mut R,
            buffer: &mut [u8],
            pos: usize,
        ) -> anyhow::Result<()> {
            reader.seek(SeekFrom::Start(pos as u64)).await?;
            reader.read_exact(buffer).await?;
            assert_eq!(buffer, &ONE_MB[pos..pos + buffer.len()]);
            Ok(())
        }

        let len = 4096;
        let mut buffer = vec![0u8; len];

        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 0).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 4096).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 25631).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 8192).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 55112).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 256256).await?;
        seek_test(&mut decrypting_reader, buffer.as_mut_slice(), 1000000).await?;

        decrypting_reader.finalize()?;
        Ok(())
    }
}
